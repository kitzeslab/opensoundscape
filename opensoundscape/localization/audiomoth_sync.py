"""utilities for synchronizing files recorded with audiomoth GPS firmware

Audio synchronization is a preprocessing step before time-difference-of-arrival based acoustic
localization. These tools use the .CSV metadata files generated by audiomoth GPS firmware to
generate audio files starting at an exact timestamp and having the exact desired sampling rate by
interpolating from the original samples and using GPS timestamps.

Example:
```python
audio = Audio.from_file('/path/to/20240801_103000.WAV')
pps_table = pps_table = pd.read_csv('/path/to/20240801_103000.CSV', index_col=0)

# create correspondence between GPS timestamps and WAV file sample positions
sample_timestamp_table = associate_pps_samples_timestamps(csv_file)

# Resample the audio second-by-second using the GPS timestamps to achieve nominal samping rate
resampled_audio = correct_sample_rate(
    audio, sample_timestamp_table, desired_sr=48000
)

# save
sample_timestamp_table.to_csv('samples_and_timestamps.csv')
resampled_audio.save('resampled_audio.wav')
```

See also:` tutorials/audiomoth_sync.py` for an example of syncing an entire dataset

NOTE: This module is in _beta_. Report issues to the opensoundscape GitHub repository.
"""

import warnings

import pandas as pd
import numpy as np
from scipy.interpolate import interp1d
from datetime import datetime
import pytz


def parse_RMC_time_to_seconds(timestamp: str) -> float:
    """
    Takes in the GPS-audiomoth formatted timestamp and returns unix epoch time in seconds.

    Args:
        timestamp: string in the format used by audiomoth GPS firmware
                '%Y-%m-%dT%H:%M:%S.%f' e.g. "2022-05-14T10:30:00.725"

    Returns: time from unix-epoch in seconds (to 10^-6s resolution) as a float
    """
    stamp_format = "%Y-%m-%dT%H:%M:%S.%f"
    return datetime.strptime(timestamp, stamp_format).timestamp()


def parse_RMC_time_to_datetime(timestamp: str) -> datetime:
    """
    Takes in the GPS-audiomoth formatted timestamp and returns datetime.datetime
    localized with UTC timezone. Assumes the input time string is given in UTC.

    Args:
        timestamp: string in the format used by our GPS-audiomoths
                '%Y-%m-%dT%H:%M:%S.%f' e.g. "2022-05-14T10:30:00.725"
    Returns: datetime object localized to UTC timezone
    """
    stamp_format = "%Y-%m-%dT%H:%M:%S.%f"
    tz = pytz.timezone("UTC")
    return tz.localize(datetime.strptime(timestamp, stamp_format))


def associate_pps_samples_timestamps(
    pps_table, expected_sr=48000, sr_tol=50, cpu_clock_counter_col="TIMER_COUNT"
) -> pd.DataFrame:
    """
    Using the CSV File from Audiomoth GPS firmware, creates a table aligning GPS_TIME_SEC values
    with the corresponding PPS and SAMPLES_WRITTEN Values

    This is the information we need to interpolate audio files to achieve "synchronized" files with
    the exact desired start time and sampling rate throughout the file.

    The interpretation of the CSV metadata file can be confusing, because it integrates information
    from (a) the Audiomoth internal state (samples written and internal clock); (b) a PPS signal, a
    voltage impulse received from the GPS once per second which is used to provide accurate timing
    information, i.e. the voltage impulse's timing corresponds to the timestamp and other metadata
    that the GPS will subsequently send in an RMC packet; and (c) RMC data, the actual data from the
    GPS (timestamp, position, positional uncertainty) which arrives some time after the PPS signal
    (e.g 0.4 seconds). Confusingly, the rows of the CSV metadata file do not contain RMC data that
    corresponds to the PPS data in the same row. Instead, the firmware writes a line to the csv as
    soon as it receives a pps impulse (meaning that it hasn't received the associated RMC data yet).
    The reason for this is that the RMC packet could be dropped and never arrive. The row includes
    the current number of samples written to the WAV file at the time of receiving the PPS signal
    (SAMPLES_WRITTEN), and the internal AudioMoth clock time (AUDIOMOTH_TIME). It also includes
    includes the _most recent previous_ RMC data (LAST_RMC_GPS_TIME) and the internal AudioMoth
    clock time for when the RMC packet was recieved (LAST_RMC_AUDIOMOTH_TIME). In a typical
    scenario, where PPS and RMC signals are arriving every second, this means that
    LAST_RMC_GPS_TIME[N+1] gives the accurate timestamp at which TOTAL_SAMPLES[N] had been recorded.
    However, PPS and/or RMC signals might not always be received every second.

    This function performs several checks to try to determine whether a value in the
    LAST_RMC_GPS_TIME column of row N+1 corresponds to the PPS from row N. If so, row N's
    SAMPLES_WRITTEN value gives the number of samples written at the time of the PPS, whose accurate
    time stamp is given by the LAST_RMC_GPS_TIME of row N+1.

    If any of the validation checks fail, we discard the RMC data from that row. As long as there is
    eventually a good pairing of RMC data (LAST_RMC_GPS_TIME) with a PPS, we will know the number of
    samples written and the exact time interval during which they were recorded. This allows us to
    interpolate the audio signal to achieve the nominal sampling rate.

    We also check for buffer overflows, which are recorded in the metadata if they occur. A buffer
    overflow occurs if the memory buffer of samples arriving from the ADC fills up and is cleared
    before the samples are written to the WAV file on the SD card. If a buffer overflow occurs, the
    WAV file will be missing samples, leading to misalignment of all samples after the buffer
    overflow compared to their expected timing. They might occur if the SD card is slow or too many
    files are being written simultaneously. This function intentionally fails if buffer overlfows
    are detected. However, it may be possible to correct for buffer overflows by detecting when they
    occur and inserting zero-valued samples for the missing samples so that subsequent samples occur
    at the correct time.

    Args:
        pps_table: dataframe containing the .CSV metadata file written by AudioMoth GPS firmware
            Set first column as index, e.g. `pps_table = pd.read_csv(path, index_col=0)`.
            (one CSV file has PPS data for a one WAV audio file)

        expected_sr: expected sample rate of the input audio

        sr_tol: tolerance for observed vs expected sample rate

        cpu_clock_counter_col: name of the column containing the CPU clock counter
            - default is "TIMER_COUNT" for the public Audiomoth GPS sync firmware
            - specify "COUNTER" for older firmware such as AudioMothGPSDeploy_1_0_8_Hardware_1_1

    Returns:
        - a DataFrame with rows in which GPS_TIME_SEC is matched with the corresponding PPS,
          SAMPLES_WRITTEN, and TIMER_COUNT values

        columns: ["PPS","SAMPLES_WRITTEN", "GPS_TIME_SEC", "GPS_TIME_STR", "CPU_CLOCK_COUNTER"]
    """

    samples_written = []
    gps_times_str = []
    gps_times_sec = []
    pps_numbers_out = []
    counter_positions = []

    pps_pings_with_no_RMC = []

    # Buffer overflow check: Fail if any buffer overflows occurred
    # a buffer overflow can be detected by a permanent difference of a multiple of 8 between
    # BUFFERS_FILLED and BUFFERS_WRITTEN. A difference of 8 corresponds to 2^17 samples that were
    # recorded from the sensor but never written to the WAV file. Thus TOTAL_SAMPLES is incorrect,
    # it overstates the number of samples actually written to the WAV file (it accurately reports the
    # number of samples recorded from the sensor into the buffer).
    # It may be possible to correct for buffer overflows by inserting 0s at the appropriate positions
    # in the WAV file, but here we fail rather than trying to correct buffer overflows.
    final_row = pps_table.iloc[-1]
    assert (
        final_row["BUFFERS_FILLED"] - final_row["BUFFERS_WRITTEN"] < 8
    ), "Buffer overflow detected, WAV file has missing content"

    pps_numbers = pps_table.index

    # PPS Duplicate Check: check for duplicates in PPS number
    if sum(pps_numbers.duplicated()) > 0:
        raise ValueError(
            f"PPS numbers are duplicated in this file. Something may be wrong: {path}"
        )

    # PPS Sequence Check: check that PPS numbers are sequential from first to last
    assert np.array_equal(
        pps_numbers.values, list(range(pps_numbers[0], pps_numbers[-1] + 1))
    ), "PPS Numbers were not sequential integers"

    for i, pps_number in enumerate(pps_numbers):
        if i == 0:  #: # if first pps ping, ignore
            # TOTAL_SAMPLES starts at zero check
            assert (
                pps_table.loc[pps_numbers[i], "TOTAL_SAMPLES"] == 0
            ), "TOTAL_SAMPLES was not zero in first row of PPS file!"
            continue
        if pd.isnull(pps_table.loc[pps_numbers[i], "LAST_RMC_AUDIOMOTH_TIME"]):
            # no RMC data in this row
            continue

        # pps_table contains a row for each pps ping recieved, written immediately when the pps is recieved
        # the SAMPLES_WRITTEN column contains the current number of samples recorded to the WAV file
        #
        # The RMC data packet with GPS information relevant to a PPS arrives after the PPS
        # A row contains the _most recent_ RMC data. So if we are making one row per second and getting data
        # as expected, the RMC info will be in the row _after_ the PPS ping row to which it corresponds.
        # The RMC data includes the audiomoth time at which the RMC was recieved, and should be after the
        # pervious row's PPS Audiomoth time but before the current row's PPS Audiomoth time.
        #
        # let's call this row row1 and the previous row row0
        # check that LAST_RMC_AUDIOMOTH_TIME falls between AUDIOMOTH_TIME of row0 and row1
        # which are the times when the PPS ping was recieved, according to the AudioMoth clock.
        # If true, the RMC data in row1 corresponds to PPS ping in row0
        # So we can pair SAMPLES_WRITTEN from row0 with LAST_RMC_GPS_TIME from row1 to know
        # the number samples taken at an accurate timestamp
        row1 = pps_table.loc[pps_number]
        row0 = pps_table.loc[pps_numbers[i - 1]]

        # GPS Status Check
        # The GPS status should be "A" if it is synced properly
        # if not, discard this RMC info and go to the next row
        if row1["STATUS"] != "A":
            continue

        rmc_gps_time_str = row1["LAST_RMC_GPS_TIME"]
        """Accurate timestamp associated with the PPS, from RMC data packet"""

        rmc_gps_time = parse_RMC_time_to_seconds(rmc_gps_time_str)
        """Accurate timestamp associated with the PPS, from RMC data packet"""

        # GPS_TIME integer check: GPS_TIME should contain even seconds
        # if not, eg 3.301, something is wrong. Discard this RMC info and go to the next row
        if not np.isclose(rmc_gps_time % 1, 0, 1e-3):
            # print(f'rmc time was non-integer: pps: {pps_number}, gps time {rmc_gps_time}')
            continue  # non-integer RMC GPS TIME! Not a valid behavior

        # parse the timestamp of the LAST_RMC_AUDIOMOTH_TIME from this row, row1
        rmc_arrival_amtime = parse_RMC_time_to_seconds(row1["LAST_RMC_AUDIOMOTH_TIME"])
        """internal Audiomoth clock time at wich the RMC packet was received"""

        # parse the timestamp of AUDIOMOTH_TIME (time PPS was recieved, internal clock) for previous row, row0
        pps_arrival_amtime = parse_RMC_time_to_seconds(row0["AUDIOMOTH_TIME"])
        """internal Audiomoth clock time at which the PPS signal was received"""

        sample_count_at_pps_arrival = row0["TOTAL_SAMPLES"]
        """total number of samples recorded when PPS arrived"""

        cpu_clock_counter = row0[cpu_clock_counter_col]
        """Position of tye CPU clock % 1000 at time of PPS ping"""

        # RMC within one second of previous PPS check:
        # check that the RMC packet for this row was received within one second of the previous row's PPS
        # if so, we match the RMC packet's GPS timestamp with the previous PPS ping's info about samples recorded
        # we are using the internal AudioMoth clock to check the relative arrival time of messages, no GPS time is used yet
        # Note that sometimes the RMC packet for PPS 4 arrives (eg 0.3 seconds) after the arrival of PPS 5, so this condition can
        # be true even if the pairing is not correct. "observed sample rate check" below attempts to catch these scenarios.
        if not (pps_arrival_amtime < rmc_arrival_amtime < pps_arrival_amtime + 1.0):
            # this row's RMC data does not correspond to the previous row's PPS ping
            # so we don't add it to our table of accurate time and number of samples
            pps_pings_with_no_RMC.append(pps_number)
            continue

        # observed sample rate check
        # check observed sample rate since the last RMC + PPS pairing, if off by more than tolerance,
        # we assume this RMC is not aligned with the correct PPS
        # for example, the RMC message for PPS 4 may have arrived after PPS 5, so we would be attemping to pair
        # row1's RMC GPS time with the incorrect PPS information (SAMPLES_WRITTEN)
        # can only check if we have one pairing already, so skip the first row
        if len(samples_written) > 0:
            observed_sr = (sample_count_at_pps_arrival - samples_written[-1]) / (
                rmc_gps_time - gps_times_sec[-1]
            )
            if abs(observed_sr - expected_sr) > sr_tol:
                print(
                    f"Observed sr {observed_sr} did not match expected {expected_sr} at PPS {pps_number}. Discarding RMC."
                )
                continue

        # all of our checks have passed.
        # add the information to our lists of paired accurate time + samples take
        samples_written.append(sample_count_at_pps_arrival)
        gps_times_str.append(rmc_gps_time_str)
        pps_numbers_out.append(pps_numbers[i - 1])
        gps_times_sec.append(rmc_gps_time)
        # also save the cpu counter position in case higher precision sync is desired
        counter_positions.append(cpu_clock_counter)

    if len(pps_pings_with_no_RMC) > 0:
        print(
            f"{len(pps_pings_with_no_RMC)} PPS pings did not have corresponding RMC data"
        )

    return pd.DataFrame(
        zip(
            pps_numbers_out,
            samples_written,
            gps_times_sec,
            gps_times_str,
            counter_positions,
        ),
        columns=[
            "PPS",
            "SAMPLES_WRITTEN",
            "GPS_TIME_SEC",
            "GPS_TIME_STR",
            "CPU_CLOCK_COUNTER",
        ],
    )


def correct_sample_rate(
    audio,
    sample_timestamp_df,
    desired_sr,
    expected_sr=48000,
    interpolation_method="nearest",
    sr_warning_tolerance=100,
):
    """Resample audio file to a nominal sample rate using PPS metadata

    We will resample the audio piece by piece, taking the samples recorded between each sequential
    pair of accurate GPS timestamps and resampling to the nominal sampling rate

    Error/fluxuation in sampling rate is corrected for segements of audio between each RMC datapoint
    For example, if pps pings are received every second and desired_sr = 48000 the first second is
    corrected to be exactly 48000, the second second is corrected to be exactly 48000 samples. These
    are concatenated to form the entire audio file.


    Args:
        - audio: Audio objecte
        - sample_timestamp_df: a dataframe of samples written to the wav file and the corresponding RMC
          time, typically created with associate_pps_samples_timestamps()
            must contain 2 required columns:  SAMPLES_WRITTEN and RMC_TIME
        - desired_sr:   the desired sample_rate for the files.
        - expected_sr: the expected sample rate of the input;
            gives warning if input sr differs by more than sr_warning_tolerance Hz on any interval
        - interpolation_method: Can be e.g. "linear", "quadratic", "nearest". See
          scipy.interpolate.interp1d docs.
            nearest is slightly faster than linear
        - sr_warning_tolerance: gives warning if input sr differs by more than sr_warning_tolerance
          Hz on any interval
    Returns:
        - Audio object with desired sample rate and updated .metadata['recording_start_time']

    Effects:
        writes out a .wav file with corrected sample_rate

    """

    dtype = audio.samples.dtype
    new_samples = []  # make container for the resampled samples

    # We will resample the audio piece by piece, taking the samples recorded between each sequential
    # pair of accurate GPS timestamps and resampling to the nominal sampling rate
    for i in sample_timestamp_df.index[1:]:
        # don't do first row - there are 0 samples written so far!
        # find start and stop sample indices in the WAV file taken between RMC_TIME of the previous and current row
        # the samples we want are [previous row SAMPLES WRITTEN, this row SAMPLES_WRITTEN)
        # ie [include, exclude); python's `list[a:b]` syntax provides the desired slice [a,b)
        this_row = sample_timestamp_df.loc[i]
        previous_row = sample_timestamp_df.loc[i - 1]
        end_sample_exclude = this_row["SAMPLES_WRITTEN"]
        start_sample = previous_row["SAMPLES_WRITTEN"]

        time_elapsed = this_row["GPS_TIME_SEC"] - previous_row["GPS_TIME_SEC"]
        observed_sr = (end_sample_exclude - start_sample) / time_elapsed

        # check that the observed_sr is close to the desired_sr
        if abs(observed_sr - expected_sr) > sr_warning_tolerance:
            warnings.warn(
                f"observed_sr = {observed_sr} is more than {sr_warning_tolerance} Hz away from desired_sr = {expected_sr}. \
                  This may indicate a problem like missing audio data, or an error in the timestamps in the pps file. \
                  The offending line number in preprocessed_pps_df: {i}; PPS number {this_row['PPS']}"
            )

        ##interpolate samples to achieve desired_sr across the time interval
        raw_samples = audio.samples[start_sample:end_sample_exclude]
        # TODO try including 1 before and 1 after second period, so we can better interpolate?
        # time in seconds of each sample, assuming samples were taken at a constant rate (even spacing)
        x_values = np.arange(len(raw_samples)) / observed_sr
        # need to extrapolate for the points outside the original data (e.g. beginning and ends if upsampling)
        interpolator = interp1d(
            x_values, raw_samples, kind=interpolation_method, fill_value="extrapolate"
        )
        # TODO do we need to check that this int rounding is OK? What if the rounding is adding some error?
        desired_x = np.arange(int(time_elapsed * desired_sr)) / desired_sr
        resampled = interpolator(desired_x)
        assert len(resampled) == int(time_elapsed * desired_sr)
        resampled = resampled.astype(dtype=dtype)

        new_samples.append(resampled)

    samples_out = np.concatenate(new_samples)
    # create new audio object with same metadata as the original
    new_audio = audio._spawn(samples=samples_out, sample_rate=desired_sr)
    # update the 'recording_start_time' in audio.metadata to the accurate timestamp
    start_time = sample_timestamp_df.loc[0, "GPS_TIME_STR"]
    if new_audio.metadata is None:
        new_audio.metadata = {}
    new_audio.metadata["recording_start_time"] = parse_RMC_time_to_datetime(start_time)

    return new_audio
